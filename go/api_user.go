/*
 * 挣闲钱
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Contact: apiteam@swagger.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	//"encoding/binary"
	"encoding/json"
	//"encoding/binary"
  	"fmt"
    "log"
	"net/http"
	//"net/url"
    "strings"
	//"errors"
	"strconv"
	"time"
    //"github.com/codegangsta/negroni"
	//"github.com/boltdb/bolt"
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
	"github.com/dgrijalva/jwt-go"
	"github.com/dgrijalva/jwt-go/request"
	//"io/ioutil"
	//"reflect"
)

type Token struct {
    Token string `json:"token"`
}

var userId int

//完成
func AcceptTask(w http.ResponseWriter, r *http.Request) {
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()
	fmt.Printf(string(userId))

	userAndtask := UserAndTask{
		TaskId: 0,
		UserId: 0,
	}

	err = json.NewDecoder(r.Body).Decode(&userAndtask)

	if err != nil {
		log.Fatal(err)
	}

	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			query, err := db.Query("INSERT INTO `mytest`.`userTask` (`taskId`, `userId`) VALUES ('" + 
				strconv.Itoa(userAndtask.TaskId) + "', '" + strconv.Itoa(userAndtask.UserId) + "')")
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			//JsonResponse(questionareTask, w, http.StatusOK)
			JsonResponse(userAndtask, w, 201)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}
//完成
func FinishAccept(w http.ResponseWriter, r *http.Request) {
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()


	userAndtask := UserAndTask{
		TaskId: 0,
		UserId: 0,
	}

	err = json.NewDecoder(r.Body).Decode(&userAndtask)

	if err != nil {
		log.Fatal(err)
	}

	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			query, err := db.Query("DELETE FROM `mytest`.`usertask` WHERE taskId = " + 
				strconv.Itoa(userAndtask.TaskId) + " and userId = " + strconv.Itoa(userAndtask.UserId))
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			//JsonResponse(questionareTask, w, http.StatusOK)
			w.Header().Set("Content-Type", "application/json; charset=UTF-8")
			w.Header().Set("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "X-Requested-With,Content-Type")
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.WriteHeader(204)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}
//测试
func FinishPublish(w http.ResponseWriter, r *http.Request) {
	db, err := sql.Open("mysql", "mytest:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()


	task := Task{
		TaskId: 0,
		TaskType: "",
		TaskTitle: "",
		EndTime: "",
		UserId: 0,
	}

	err = json.NewDecoder(r.Body).Decode(&task)

	if err != nil {
		log.Fatal(err)
	}

	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			query, err := db.Query("DELETE FROM `mytest`.`task` WHERE taskId = " + strconv.Itoa(task.TaskId))
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()
			var taskTypeId string
			if task.TaskType == "questionare" {
				taskTypeId = "queryId"
			} else {
				taskTypeId = "deliveryId"
			}
			query, err = db.Query("DELETE FROM `mytest`.`" + task.TaskType + "` WHERE " + taskTypeId + " = " + strconv.Itoa(task.TaskId))
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			//JsonResponse(questionareTask, w, http.StatusOK)
			w.Header().Set("Content-Type", "application/json; charset=UTF-8")
			w.Header().Set("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "X-Requested-With,Content-Type")
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.WriteHeader(204)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}

//完成
func GetUser(w http.ResponseWriter, r *http.Request) {
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	queryUserId := strings.Split(r.URL.Path, "/")[2]
	_, err = strconv.Atoi(queryUserId)
	if err != nil {
		reponse := ErrorResponse{"Wrong UserId"}
		JsonResponse(reponse, w, http.StatusNotFound)
		return
	}
	
	query, err := db.Query("select * from mytest.user where userId=" + queryUserId)
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()

	v, err := getJSON(query)
	if err != nil {
		log.Fatal(err)
	}

	if string(v) == "[]" {
		reponse := ErrorResponse{"userId Not Exists"}
		JsonResponse(reponse, w, http.StatusNotFound)
		return
	}
	v = v[1:len(v)-1]
	
	str := strings.Replace(string(v), "balance\":\"", "balance\":", -1)
	str = strings.Replace(str, "\",\"email", ",\"email", -1)
	str = strings.Replace(str, "userId\":\"", "userId\":", -1)
	str = strings.Replace(str, "\",\"username", ",\"username", -1)
	v = []byte(str)
	fmt.Printf(string(v))
	
	var user User
	
	_ = json.Unmarshal(v, &user)
	JsonResponse(user, w, http.StatusOK)
}

//测试
func PublishDTask(w http.ResponseWriter, r *http.Request) {
	db, err := sql.Open("mysql", "mytest:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	query, err := db.Query("select * from mytest.task order by taskId desc limit 1")
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()

	v, err := getJSON(query)
	if err != nil {
		log.Fatal(err)
	}

	taskId := 9999
	var finalTask Task
	if string(v) != "[]" {
		v = v[1:len(v)-1]
		str := strings.Replace(string(v), "taskId\":\"", "taskId\":", -1)
		str = strings.Replace(str, "\",\"taskTitle", ",\"taskTitle", -1)
		str = strings.Replace(str, "userId\":\"", "userId\":", -1)
		str = strings.Replace(str, "\"}", "}", -1)
		v = []byte(str)
		_ = json.Unmarshal(v, &finalTask)
		taskId = finalTask.TaskId
	}

	task := Task{
		TaskId: taskId + 1,
		TaskType: "",
		TaskTitle: "",
		EndTime: "",
		UserId: userId,
	}

	delivery := Delivery{
		DeliveryId: taskId + 1,
		Content: "",
	}

	deliveryTask := DeliveryTask{
		Task: task,
		Delivery: delivery,
	}

	err = json.NewDecoder(r.Body).Decode(&deliveryTask)

	if err != nil {
		log.Fatal(err)
	}

	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			query, err = db.Query("INSERT INTO `mytest`.`task` (`taskId`, `taskType`, `taskTitle`, `endTime`, `userId`) VALUES ('" + 
			strconv.Itoa(deliveryTask.Task.TaskId) + "', '" + deliveryTask.Task.TaskType + "', '" + deliveryTask.Task.TaskTitle + 
					"', '" +  deliveryTask.Task.EndTime + "', '" + strconv.Itoa(deliveryTask.Task.UserId) + "')")
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			query, err = db.Query("INSERT INTO `mytest`.`delivery` (`deliveryId`, `content`) VALUES ('" + 
				strconv.Itoa(deliveryTask.Delivery.DeliveryId) + "', '" + deliveryTask.Delivery.Content + "')")
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			JsonResponse(deliveryTask, w, http.StatusOK)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}

//测试
func PublishQTask(w http.ResponseWriter, r *http.Request) {  
	db, err := sql.Open("mysql", "mytest:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	query, err := db.Query("select * from mytest.task order by taskId desc limit 1")
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()

	v, err := getJSON(query)
	if err != nil {
		log.Fatal(err)
	}

	taskId := 9999
	var finalTask Task
	if string(v) != "[]" {
		v = v[1:len(v)-1]
		str := strings.Replace(string(v), "taskId\":\"", "taskId\":", -1)
		str = strings.Replace(str, "\",\"taskTitle", ",\"taskTitle", -1)
		str = strings.Replace(str, "userId\":\"", "userId\":", -1)
		str = strings.Replace(str, "\"}", "}", -1)
		v = []byte(str)
		_ = json.Unmarshal(v, &finalTask)
		taskId = finalTask.TaskId
	}

	task := Task{
		TaskId: taskId + 1,
		TaskType: "",
		TaskTitle: "",
		EndTime: "",
		UserId: userId,
	}

	questionare := Questionare{
		Queryid: taskId + 1,
		Content: "",
	}

	questionareTask := QuestionareTask{
		Task: task,
		Questionare: questionare,
	}

	err = json.NewDecoder(r.Body).Decode(&questionareTask)

	if err != nil {
		log.Fatal(err)
	}

	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			query, err = db.Query("INSERT INTO `mytest`.`task` (`taskId`, `taskType`, `taskTitle`, `endTime`, `userId`) VALUES ('" + 
			strconv.Itoa(questionareTask.Task.TaskId) + "', '" + questionareTask.Task.TaskType + "', '" + questionareTask.Task.TaskTitle + 
					"', '" +  questionareTask.Task.EndTime + "', '" + strconv.Itoa(questionareTask.Task.UserId) + "')")
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			query, err = db.Query("INSERT INTO `mytest`.`questionare` (`queryId`, `content`) VALUES ('" + 
				strconv.Itoa(questionareTask.Questionare.Queryid) + "', '" + questionareTask.Questionare.Content + "')")
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			JsonResponse(questionareTask, w, http.StatusOK)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}

//完成
func SignIn(w http.ResponseWriter, r *http.Request) {
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	var user User

	err = json.NewDecoder(r.Body).Decode(&user)

	if err != nil {
			response := ErrorResponse{err.Error()}
			JsonResponse(response, w, http.StatusBadRequest)
			return
	}

	query, err := db.Query("select * from mytest.user where userId='" + strconv.Itoa(user.UserId) + "'")
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()

	v, err := getJSON(query)
	if err != nil {
		log.Fatal(err)
	}

	if string(v) == "[]" {
		reponse := ErrorResponse{"Wrong userId or Password"}
		JsonResponse(reponse, w, http.StatusBadRequest)
		return
	}

	var userQuery User
	v = v[1:len(v)-1]
	_ = json.Unmarshal(v, &userQuery)

	if userQuery.Password != user.Password {
		response := ErrorResponse{"Wrong userId or Password"}
		JsonResponse(response, w, http.StatusBadRequest)
		return
	}

	token := jwt.New(jwt.SigningMethodHS256)
	claims := make(jwt.MapClaims)
	claims["exp"] = time.Now().Add(time.Hour * time.Duration(1)).Unix()
	claims["iat"] = time.Now().Unix()
	token.Claims = claims

	if err != nil {
		log.Fatal(err)
	}
	userId = user.UserId
	tokenString, err := token.SignedString([]byte(string(user.UserId)))
	if err != nil {
		log.Fatal(err)
	}

	response := Token{tokenString}
	JsonResponse(response, w, http.StatusOK)
}

//完成 需加强身份验证
func SignUp(w http.ResponseWriter, r *http.Request) {
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	var user User
	err = json.NewDecoder(r.Body).Decode(&user)
	//fmt.Printf(err.Error())
	if err != nil || user.Password == "" || user.Username == "" {
			response := ErrorResponse{"Wrong Username or Password"}
			JsonResponse(response, w, http.StatusBadRequest)
			return
	}

	query, err := db.Query("select * from mytest.user order by userId desc limit 1")
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()

	v, err := getJSON(query)
	if err != nil {
		log.Fatal(err)
	}

	user.UserId = 10000
	var finaluser User
	if string(v) != "[]" {
		v = v[1:len(v)-1]
		str := strings.Replace(string(v), "balance\":\"", "balance\":", -1)
		str = strings.Replace(str, "\",\"email", ",\"email", -1)
		str = strings.Replace(str, "userId\":\"", "userId\":", -1)
		str = strings.Replace(str, "\",\"username", ",\"username", -1)
		v = []byte(str)
		_ = json.Unmarshal(v, &finaluser)
		user.UserId = finaluser.UserId + 1
	}

	query, err = db.Query("INSERT INTO `mytest`.`user` (`userId`, `username`, `password`, `university`, `grade`, `phone`, `major`, `email`, `balance`) VALUES ('"  +
	  strconv.Itoa(user.UserId) + "', '" + user.Username + "', '" + user.Password + "', '" + 
	    user.University + "', '" + user.Grade + "', '"  + user.Phone +  "', '" + user.Major + "', '" + user.Email + "', '" + strconv.Itoa(user.Balance) + "')")
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()
	JsonResponse(user, w, 201)
	
}
