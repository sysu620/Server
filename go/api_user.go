/*
 * 挣闲钱
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Contact: apiteam@swagger.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	//"encoding/binary"
	"encoding/json"
	//"encoding/binary"
  	"fmt"
    "log"
	"net/http"
	//"net/url"
    "strings"
	//"errors"
	"strconv"
	"time"
    //"github.com/codegangsta/negroni"
	//"github.com/boltdb/bolt"
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
	"github.com/dgrijalva/jwt-go"
	"github.com/dgrijalva/jwt-go/request"
	//"io/ioutil"
	//"reflect"
)

type Token struct {
    Token string `json:"token"`
}

var userId int

//完成
func AcceptTask(w http.ResponseWriter, r *http.Request) {
	//userId = 10000
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()
	fmt.Printf(string(userId))

	userAndtask := UserAndTask{
		TaskId: 0,
		UserId: 0,
		State: "已接取",
	}

	err = json.NewDecoder(r.Body).Decode(&userAndtask)
	userAndtask.UserId = userId
	userAndtask.State = "已接取"
	if err != nil {
		log.Fatal(err)
	}

	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			query, err := db.Query("select * from mytest.task where userId=" + strconv.Itoa(userAndtask.UserId) + 
				" and taskId=" + strconv.Itoa(userAndtask.TaskId))
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()
			v, err := getJSON(query)
			if err != nil {
				log.Fatal(err)
			}
		
			if string(v) != "[]" {
				reponse := ErrorResponse{"The task is published by the user"}
				JsonResponse(reponse, w, http.StatusBadRequest)
				return
			}

			query, err = db.Query("INSERT INTO `mytest`.`userTask` (`taskId`, `userId`, `state`) VALUES ('" + 
				strconv.Itoa(userAndtask.TaskId) + "', '" + strconv.Itoa(userAndtask.UserId) + "', '" + userAndtask.State + "')")
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			//JsonResponse(questionareTask, w, http.StatusOK)
			JsonResponse(userAndtask, w, 201)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}
//完成
func FinishAccept(w http.ResponseWriter, r *http.Request) {
	//userId = 10004
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()


	userAndtask := UserAndTask{
		TaskId: 0,
		UserId: 0,
	}

	err = json.NewDecoder(r.Body).Decode(&userAndtask)

	userAndtask.State = "已完成"
	userAndtask.UserId = userId
	if err != nil {
		log.Fatal(err)
	}

	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			query, err := db.Query("UPDATE `mytest`.`usertask` SET state = '已完成' WHERE taskId = " + 
				strconv.Itoa(userAndtask.TaskId) + " and userId = " + strconv.Itoa(userAndtask.UserId))
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			//JsonResponse(questionareTask, w, http.StatusOK)
			w.Header().Set("Content-Type", "application/json; charset=UTF-8")
			w.Header().Set("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "X-Requested-With,Content-Type")
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.WriteHeader(204)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}
//完成 
func FinishPublish(w http.ResponseWriter, r *http.Request) {
	//userId = 10004
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()


	task := Task{
		TaskId: 0,
		TaskType: "",
		TaskTitle: "",
		EndTime: "",
		UserId: 0,
	}

	err = json.NewDecoder(r.Body).Decode(&task)

	if err != nil {
		log.Fatal(err)
	}
	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			query, err := db.Query("UPDATE `mytest`.`task` SET State = '已完成' WHERE taskId = " + strconv.Itoa(task.TaskId))
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			//JsonResponse(questionareTask, w, http.StatusOK)
			w.Header().Set("Content-Type", "application/json; charset=UTF-8")
			w.Header().Set("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "X-Requested-With,Content-Type")
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.WriteHeader(204)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}

//完成
func GetUser(w http.ResponseWriter, r *http.Request) {
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	queryUserId := strings.Split(r.URL.Path, "/")[2]
	_, err = strconv.Atoi(queryUserId)
	if err != nil {
		reponse := ErrorResponse{"Wrong UserId"}
		JsonResponse(reponse, w, http.StatusNotFound)
		return
	}
	
	query, err := db.Query("select * from mytest.user where userId=" + queryUserId)
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()

	v, err := getJSON(query)
	if err != nil {
		log.Fatal(err)
	}

	if string(v) == "[]" {
		reponse := ErrorResponse{"userId Not Exists"}
		JsonResponse(reponse, w, http.StatusNotFound)
		return
	}
	v = v[1:len(v)-1]
	
	str := strings.Replace(string(v), "balance\":\"", "balance\":", -1)
	str = strings.Replace(str, "\",\"email", ",\"email", -1)
	str = strings.Replace(str, "userId\":\"", "userId\":", -1)
	str = strings.Replace(str, "\",\"username", ",\"username", -1)
	v = []byte(str)
	fmt.Printf(string(v))
	
	var user User
	
	_ = json.Unmarshal(v, &user)
	JsonResponse(user, w, http.StatusOK)
}

//完成
func PublishDTask(w http.ResponseWriter, r *http.Request) {
	//userId = 10005
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	query, err := db.Query("select * from mytest.task order by taskId desc limit 1")
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()

	v, err := getJSON(query)
	if err != nil {
		log.Fatal(err)
	}
	var taskId int
	taskId = 9999
	var finalTask Task
	if string(v) != "[]" {
		v = v[1:len(v)-1]
		str := strings.Replace(string(v), "taskId\":\"", "taskId\":", -1)
		str = strings.Replace(str, "\",\"taskTitle", ",\"taskTitle", -1)
		str = strings.Replace(str, "userId\":\"", "userId\":", -1)
		str = strings.Replace(str, "\"}", "}", -1)
		v = []byte(str)
		_ = json.Unmarshal(v, &finalTask)
		taskId = finalTask.TaskId
	}
	
	task := Task{
		TaskId: taskId + 1,
		TaskType: "",
		TaskTitle: "",
		EndTime: "",
		UserId: userId,
		State: "进行中",
	}
	delivery := Delivery{
		DeliveryId: taskId + 1,
		Content: "",
	}

	deliveryTask := DeliveryTask{
		Task: task,
		Delivery: delivery,
	}

	err = json.NewDecoder(r.Body).Decode(&deliveryTask)
	deliveryTask.Task.TaskId = taskId + 1
	deliveryTask.Task.UserId = userId
	deliveryTask.Task.State = "进行中"
	deliveryTask.Delivery.DeliveryId = taskId + 1
	if err != nil {
		log.Fatal(err)
	}

	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })
	
    if err == nil {
        if token.Valid {
			fmt.Printf(strconv.Itoa(deliveryTask.Task.TaskId))
			query, err = db.Query("INSERT INTO `mytest`.`task` (`taskId`, `taskType`, `taskTitle`, `endTime`, `userId`, `state`) VALUES ('" + 
			strconv.Itoa(deliveryTask.Task.TaskId) + "', '" + deliveryTask.Task.TaskType + "', '" + deliveryTask.Task.TaskTitle + 
					"', '" +  deliveryTask.Task.EndTime + "', '" + strconv.Itoa(deliveryTask.Task.UserId) + "', '" + deliveryTask.Task.State + "')")
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			query, err = db.Query("INSERT INTO `mytest`.`delivery` (`deliveryId`, `content`) VALUES ('" + 
				strconv.Itoa(deliveryTask.Delivery.DeliveryId) + "', '" + deliveryTask.Delivery.Content + "')")
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()

			JsonResponse(deliveryTask, w, http.StatusOK)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}

//完成
func PublishQTask(w http.ResponseWriter, r *http.Request) {  
	//userId = 10004
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	query, err := db.Query("select * from mytest.task order by taskId desc limit 1")
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()

	v, err := getJSON(query)
	if err != nil {
		log.Fatal(err)
	}

	taskId := 9999
	var finalTask Task
	if string(v) != "[]" {
		v = v[1:len(v)-1]
		str := strings.Replace(string(v), "taskId\":\"", "taskId\":", -1)
		str = strings.Replace(str, "\",\"taskTitle", ",\"taskTitle", -1)
		str = strings.Replace(str, "userId\":\"", "userId\":", -1)
		str = strings.Replace(str, "\"}", "}", -1)
		v = []byte(str)
		_ = json.Unmarshal(v, &finalTask)
		taskId = finalTask.TaskId
	}


	//var questionares []Questionare
	var questionareTask QuestionareTask
	//fmt.Printf(strconv.Itoa(questionareTask.Questionare.Queryid))
	err = json.NewDecoder(r.Body).Decode(&questionareTask)

	for i, _ := range questionareTask.Questionare {
		questionareTask.Questionare[i].QuestionareId = taskId + 1
		questionareTask.Questionare[i].Num = i + 1
	}

	questionareTask.Task.TaskId = taskId + 1
	questionareTask.Task.UserId = userId
	questionareTask.Task.State = "进行中"
	if err != nil {
		log.Fatal(err)
	}

	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			query, err = db.Query("INSERT INTO `mytest`.`task` (`taskId`, `taskType`, `taskTitle`, `endTime`, `userId`, `state`) VALUES ('" + 
			strconv.Itoa(questionareTask.Task.TaskId) + "', '" + questionareTask.Task.TaskType + "', '" + questionareTask.Task.TaskTitle + 
					"', '" +  questionareTask.Task.EndTime + "', '" + strconv.Itoa(questionareTask.Task.UserId) + "', '" + questionareTask.Task.State + "')")
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()
			
			for _, questionare := range questionareTask.Questionare {
				
				query, err = db.Query("INSERT INTO `mytest`.`questionare` (`questionareId`, `num`, `title`, `type`, `isNeed`, `options`) VALUES ('" + 
					strconv.Itoa(questionare.QuestionareId) + "', '" + strconv.Itoa(questionare.Num) + "', '" + questionare.Title + "', '" +
						questionare.Type + "', '" + questionare.IsNeed + "', '" + questionare.Options + "')")
				if err != nil {
					log.Fatal(err)
				}
				defer query.Close()
			}
			JsonResponse(questionareTask, w, http.StatusOK)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}

//完成
func SignIn(w http.ResponseWriter, r *http.Request) {
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	var user User

	err = json.NewDecoder(r.Body).Decode(&user)

	if err != nil {
			fmt.Printf(err.Error())
			response := ErrorResponse{err.Error()}
			JsonResponse(response, w, http.StatusBadRequest)
			return
	}

	query, err := db.Query("select * from mytest.user where userId='" + strconv.Itoa(user.UserId) + "'")
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()

	v, err := getJSON(query)
	if err != nil {
		log.Fatal(err)
	}

	if string(v) == "[]" {
		fmt.Printf(strconv.Itoa(user.UserId))
		reponse := ErrorResponse{"Wrong userId or Password"}
		JsonResponse(reponse, w, http.StatusBadRequest)
		return
	}

	var userQuery User
	v = v[1:len(v)-1]
	_ = json.Unmarshal(v, &userQuery)

	if userQuery.Password != user.Password {
		response := ErrorResponse{"Wrong userId or Password"}
		JsonResponse(response, w, http.StatusBadRequest)
		return
	}

	token := jwt.New(jwt.SigningMethodHS256)
	claims := make(jwt.MapClaims)
	claims["exp"] = time.Now().Add(time.Hour * time.Duration(1)).Unix()
	claims["iat"] = time.Now().Unix()
	token.Claims = claims

	if err != nil {
		log.Fatal(err)
	}
	userId = user.UserId
	tokenString, err := token.SignedString([]byte(string(user.UserId)))
	if err != nil {
		log.Fatal(err)
	}

	response := Token{tokenString}
	JsonResponse(response, w, http.StatusOK)
}

//完成 需加强身份验证
func SignUp(w http.ResponseWriter, r *http.Request) {
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	var user User
	err = json.NewDecoder(r.Body).Decode(&user)
	//fmt.Printf(err.Error())
	if err != nil || user.Password == "" || user.Username == "" {
			response := ErrorResponse{"Wrong Username or Password"}
			JsonResponse(response, w, http.StatusBadRequest)
			return
	}

	query, err := db.Query("select * from mytest.user order by userId desc limit 1")
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()

	v, err := getJSON(query)
	if err != nil {
		log.Fatal(err)
	}

	user.UserId = 10000
	var finaluser User
	if string(v) != "[]" {
		v = v[1:len(v)-1]
		str := strings.Replace(string(v), "balance\":\"", "balance\":", -1)
		str = strings.Replace(str, "\",\"email", ",\"email", -1)
		str = strings.Replace(str, "userId\":\"", "userId\":", -1)
		str = strings.Replace(str, "\",\"username", ",\"username", -1)
		v = []byte(str)
		_ = json.Unmarshal(v, &finaluser)
		user.UserId = finaluser.UserId + 1
	}

	query, err = db.Query("INSERT INTO `mytest`.`user` (`userId`, `username`, `password`, `university`, `grade`, `phone`, `major`, `email`, `balance`) VALUES ('"  +
	  strconv.Itoa(user.UserId) + "', '" + user.Username + "', '" + user.Password + "', '" + 
	    user.University + "', '" + user.Grade + "', '"  + user.Phone +  "', '" + user.Major + "', '" + user.Email + "', '" + strconv.Itoa(user.Balance) + "')")
	if err != nil {
		log.Fatal(err)
	}
	defer query.Close()
	JsonResponse(user, w, 201)
	
}

func SignOut(w http.ResponseWriter, r *http.Request) {
	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			userId = 0

			//JsonResponse(questionareTask, w, http.StatusOK)
			w.Header().Set("Content-Type", "application/json; charset=UTF-8")
			w.Header().Set("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "X-Requested-With,Content-Type")
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.WriteHeader(200)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}

func FillQuery(w http.ResponseWriter, r *http.Request) {
	userId = 10004
	db, err := sql.Open("mysql", "root:HUANG@123@tcp(127.0.0.1:3306)/?charset=utf8")
	if err != nil {
			log.Fatal(err)
	}
	defer db.Close()

	var answers Answers

	err = json.NewDecoder(r.Body).Decode(&answers)

	if err != nil {
		log.Fatal(err)
	}

	token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor,
        func(token *jwt.Token) (interface{}, error) {
            return []byte(string(userId)), nil
        })

    if err == nil {
        if token.Valid {
			if len(answers.Contents) == 0 {
				reponse := ErrorResponse{"No answers"}
				JsonResponse(reponse, w, http.StatusBadRequest)
				return
			}
			query, err := db.Query("select * from mytest.questionare where questionareId=" + strconv.Itoa(answers.Contents[0].QuestionareId))
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()
			v, err := getJSON(query)
			if err != nil {
				log.Fatal(err)
			}
		
			if string(v) == "[]" {
				reponse := ErrorResponse{"No questionare"}
				JsonResponse(reponse, w, http.StatusBadRequest)
				return
			}
			v = v[1:len(v)-1]
			str := strings.Replace(string(v), "num\":\"", "num\":", -1)
			str = strings.Replace(str, "\",\"options", ",\"options", -1)
			str = strings.Replace(str, "questionareId\":\"", "questionareId\":", -1)
			str = strings.Replace(str, "\",\"title", ",\"title", -1)
			str = "[" + str + "]"
			v = []byte(str)
			fmt.Printf(string(v))
			var questionares []Questionare
			_ = json.Unmarshal(v, &questionares)

			query, err = db.Query("select * from mytest.answer order by answerId desc limit 1")
			if err != nil {
				log.Fatal(err)
			}
			defer query.Close()
		
			v, err = getJSON(query)
			if err != nil {
				log.Fatal(err)
			}
		
			answerId := 10000
			var finalAnswer Answer
			if string(v) != "[]" {
				v = v[1:len(v)-1]
				//str := strings.Replace(string(v), "taskId\":\"", "taskId\":", -1)
				//str = strings.Replace(str, "\",\"taskTitle", ",\"taskTitle", -1)
				//str = strings.Replace(str, "userId\":\"", "userId\":", -1)
				//str = strings.Replace(str, "\"}", "}", -1)
				//v = []byte(str)
				fmt.Printf(string(v))
				_ = json.Unmarshal(v, &finalAnswer)
				answerId = finalAnswer.AnswerId + 1
			}

			for i, questionare := range questionares {
				if questionare.IsNeed == "true" && answers.Contents[i].Answer == "" {
					reponse := ErrorResponse{"answer " + strconv.Itoa(i) + " is required"}
					JsonResponse(reponse, w, http.StatusBadRequest)
					return
				}
			}
			for i, _ := range questionares {
				answerId_ := answerId + i
				query, err = db.Query("INSERT INTO `mytest`.`answer` (`questionareId`, `answerId`, `answer`) VALUES ('" + 
				strconv.Itoa(answers.Contents[0].QuestionareId) + "', '" + strconv.Itoa(answerId_) + "', '" + answers.Contents[i].Answer + "')")
				if err != nil {
					log.Fatal(err)
				}
				defer query.Close()
			}
			//JsonResponse(questionareTask, w, http.StatusOK)
			JsonResponse(answers, w, 201)
        } else {
			response := ErrorResponse{"Token is not valid"}
			JsonResponse(response, w, http.StatusUnauthorized)
        }
    } else {
		response := ErrorResponse{"Unauthorized access to this resource"}
		JsonResponse(response, w, http.StatusUnauthorized)
    }
}
